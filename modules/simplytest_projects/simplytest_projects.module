<?php

/**
 * @file
 * Handles drupal.org project data.
 */

/**
 * Drupal.org full project GIT URL.
 */
define('SIMPLYTEST_PROJECTS_DRUPAL_ORG_PROJECT', 'http://git.drupal.org/project/');

/**
 * Drupal.org sandbox project GIT URL.
 */
define('SIMPLYTEST_PROJECTS_DRUPAL_ORG_SANDBOX', 'http://git.drupal.org/sandbox/');

/**
 * Drupal.org webgit URL.
 */
define('SIMPLYTEST_PROJECTS_DRUPALCODE_ORG', 'http://cgit.drupalcode.org/');

/**
 * Drupal.org URL
 */
define('SIMPLYTEST_PROJECTS_DRUPAL_ORG', 'http://drupal.org/');

/**
 * Drupal.org project types.
 */
define('SIMPLYTEST_PROJECTS_TYPE_CORE',   'Drupal core');
define('SIMPLYTEST_PROJECTS_TYPE_MODULE', 'Module');
define('SIMPLYTEST_PROJECTS_TYPE_THEME',  'Theme');
define('SIMPLYTEST_PROJECTS_TYPE_DISTRO', 'Distribution');

/**
 * Implements hook_menu().
 */
function simplytest_projects_menu() {
  $items = array();
  // General configuration form.
  $items['admin/simplytest/project'] = array(
    'title' => 'Projects settings',
    'description' => 'Settings of the project listings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simplytest_projects_settings_form'),
    'access arguments' => array('administer simplytest'),
    'file' => 'simplytest_projects.admin.inc',
  );
  // Project list management.
  $items['admin/simplytest/projects'] = array(
    'title' => 'Projects',
    'description' => 'Manage project list.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simplytest_projects_management_form'),
    'access arguments' => array('administer simplytest'),
    'file' => 'simplytest_projects.admin.inc',
  );
  // Version cache listing of a project.
  $items['admin/simplytest/projects/%/versions'] = array(
    'title' => 'Project versions',
    'description' => 'Cached project version listing.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simplytest_projects_version_list_form', 3),
    'access arguments' => array('administer simplytest'),
    'file' => 'simplytest_projects.admin.inc',
  );
  // Edit a project entry.
  $items['admin/simplytest/projects/%/edit'] = array(
    'title' => 'Edit project information',
    'description' => 'Edit project information.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simplytest_projects_edit_form', 3),
    'access arguments' => array('administer simplytest'),
    'file' => 'simplytest_projects.admin.inc',
  );
  // Operation on a project entry.
  $items['admin/simplytest/projects/%/%'] = array(
    'title' => 'Edit project information',
    'description' => 'Edit project information.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simplytest_projects_operation', 3, 4),
    'access arguments' => array('administer simplytest'),
    'file' => 'simplytest_projects.admin.inc',
  );
  return $items;
}

/**
 * Returns available information about a project.
 *
 * @param string $project
 *  The projects shortname to return information about.
 *
 * @return array
 *  An assocciative array containing:
 *   - title: The human readable project title.
 *   - type: The human readable project type.
 *   - creator: The drupal.org user who created it.
 *   - giturl: The project's git URL.
 *   - drupalcode_url: The projects webgit URL.
 *   - sandbox: A boolean, whether it's a sandbox.
 *   - versions: An associative array of versions containing:
 *      - tags: Existing tags of the project.
 *      - heads: Existing heads of the project.
 *   - timestamp: The last time the versions where updated.
 */
function simplytest_projects_get_project($project) {
  // Check the static cache for this function for data first.
  static $static_cache;
  if (isset($static_cache[$project])) {
    // Found project data in cache.
    return $static_cache[$project];
  }
  if (!is_array($static_cache)) {
    // Initialize static cache array.
    $static_cache = array();
  }

  // Get project information from database.
  $data = db_select('simplytest_projects', 'p')
    ->fields('p', array(
      'title',
      'type',
      'sandbox',
      'creator',
      'versions',
      'timestamp',
    ))
    ->condition('shortname', $project)
    ->execute()->fetchObject();

  if (!$data) {
    // Need to fetch initial project data.
    $data = simplytest_projects_fetch_project($project);
    if ($data === FALSE) {
      // Fetching initial data failed, also cache these results
      // so it will not be retried within the same request.
      $static_cache[$project] = FALSE;
      return FALSE;
    }
    $data = (object) $data;
  }

  // Build the git URL to clone the project from and the webgit URL.
  if ($data->sandbox) {
    // Remove special characters from the users name.
    $escaped_creator = preg_replace('/[^a-z0-9-_\.+!*\(\)\']/s', '', strtolower($data->creator));

    $giturl = SIMPLYTEST_PROJECTS_DRUPAL_ORG_SANDBOX . $escaped_creator . '/' . $project . '.git';
    $drupalcode_url = SIMPLYTEST_PROJECTS_DRUPALCODE_ORG . 'sandbox-' . $escaped_creator . '-' . $project;
  }
  else {
    $giturl = SIMPLYTEST_PROJECTS_DRUPAL_ORG_PROJECT . $project . '.git';
    $drupalcode_url = SIMPLYTEST_PROJECTS_DRUPALCODE_ORG . $project;
  }

  // Build the project data array to return.
  $project_data = array(
    'title' => $data->title,
    'type' => $data->type,
    'creator' => $data->creator,
    'giturl' => $giturl,
    'drupalcode_url' => $drupalcode_url,
    'sandbox' => (bool) $data->sandbox,
    // If initial project data has just been fetched, this wont be available.
    'versions' => empty($data->versions) ? NULL : unserialize($data->versions),
    'timestamp' => empty($data->timestamp) ? 0 : (int) $data->timestamp,
  );

  // Statically cache the data.
  $static_cache[$project] = $project_data;

  return $project_data;
}

/**
 * Searches the database for projects by prefix.
 *
 * @param string $string
 *  The prefix string to search projects for.
 * @param int $range
 *  Maximum number of results to return.
 * @param array $types
 *  An array of project types to filter for.
 *
 * @return array
 *  An array of standard objects containing:
 *   - title: The human readable project title.
 *   - type: The projects type.
 *   - shortname: The project machine/shortname.
 *   - sandbox: Whether it's a sandbox.
 */
function simplytest_projects_search_project($string, $range = 100, $types = NULL) {
  // Search it within the projects table.
  $query = db_select('simplytest_projects', 'p')
    ->fields('p', array(
      'title',
      'shortname',
      'type',
      'sandbox',
    ))
    ->orderBy('sandbox', 'ASC')
    ->range(0, $range);

  // Add OR condition: Search string in title and shortname.
  $title_or_shortname = db_or()
    ->condition('title', db_like($string) . '%', 'LIKE')
    ->condition('shortname', db_like($string) . '%', 'LIKE');
  $query->condition($title_or_shortname);

  // Filter for specific types, if needed.
  if ($types) {
    $types_or = db_or();
    foreach ($types as $type) {
      $types_or->condition('type', $type);
    }
    $query->condition($types_or);
  }

  // Execute the search query.
  $result = $query->execute()->fetchAll();

  // Filter out blacklisted projects.
  if (is_array($result) && $result) {
    foreach ($result as $id => $entry) {
      // Check results for blacklisted projects.
      foreach (variable_get('simplytest_projects_blacklisted_projects', array()) as $blacklisted) {
        if ($entry->shortname == $blacklisted) {
          unset($result[$id]);
        }
      }
    }
  }
  else {
    $result = array();
  }
  return $result;
}

/**
 * Returns all available versions for a project.
 *
 * @param string $project
 *  The project's shortname to return available versions for.
 *
 * @return array
 *  An associative array containing:
 *   - tags: Existing tags of the project.
 *   - heads: Existing heads of the project. 
 */
function simplytest_projects_get_versions($project) {
  // Check blacklist for project.
  foreach (variable_get('simplytest_projects_blacklisted_projects', array()) as $blacklisted) {
    if ($project == $blacklisted) {
      return FALSE;
    }
  }

  // Get project information.
  $project_data = simplytest_projects_get_project($project);
  if (!$project_data) {
    // If there's no such project, we don't need to try fetching its versions.
    return FALSE;
  }

  // Check whether the projects version information is not too old.
  $timeout = strtotime(variable_get('simplytest_projects_version_timeout', '-1 hour'));
  if ($project_data['timestamp'] > $timeout) {
    // Return the known version information.
    return $project_data['versions'];
  }
  else {
    // Need to fetch fresh version information.
    return simplytest_projects_fetch_versions($project);
  }
}

/**
 * Checks whether a projects commit hash is valid and exists.
 *
 * @param string $project
 *  The projects shortname to check the commit for.
 * @param string $hash
 *  The hash of a commit to validate.
 *
 * @return bool
 *  TRUE if valid, FALSE otherwise.
 */
function simplytest_projects_check_commit_hash($project, $hash) {
  // First check whether the string is a valid hash.
  if ((strlen($hash) < 6) || preg_match('/[^a-z0-9]/i', $hash)) {
    return FALSE;
  }

  // Need some project information.
  $project_data = simplytest_projects_get_project($project);
  if (!$project_data) {
    return FALSE;
  }

  // Now check whether the commit actually exists by looking it up.
  $response_status = simplytest_projects_get_http_status_code($project_data['drupalcode_url'] . '/' . $hash);
  if ($response_status != 200 && $response_status != 301 && $response_status != 304) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Fetches, saves and returns all available versions for a project.
 *
 * @param string $project
 *  The project's shortname to fetch available versions for.
 *
 * @return array
 *  An associative array containing:
 *   - tags: Existing tags of the project.
 *   - heads: Existing heads of the project.
 */
function simplytest_projects_fetch_versions($project) {
  // Check whether project is known in database.
  $project_data = simplytest_projects_get_project($project);

  // Fetch tags by request.
  $result = drupal_http_request($project_data['drupalcode_url'] . '/refs/tags');
  if (!isset($result->data) || $result->code != 200) {
    watchdog('simplytest_projects', 'Failed to fetch version data for %project (Requested tags).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    return FALSE;
  }
  // Try to match out a list of tags of the raw HTML.
  preg_match_all('!<tr><td><a href=\'/.*/tag/[^\']*\'>([^<]*)</a></td>!', $result->data, $tags);
  if(!isset($tags[1])) {
    watchdog('simplytest_projects', 'Failed to fetch version data for %project (Fetched tags).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    return FALSE;
  }

  // Fetch branches by request.
  $result = drupal_http_request($project_data['drupalcode_url'] . '/refs/heads');
  if (!isset($result->data) || $result->code != 200) {
    watchdog('simplytest_projects', 'Failed to fetch version data for %project (Requested heads).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    return FALSE;
  }
  // Try to match out a list of tags of the raw HTML.
  preg_match_all('!<tr><td><a href=\'/.*/log/[^\']*\'>([^<]*)</a></td>!', $result->data, $heads);
  if(!isset($heads[1])) {
    watchdog('simplytest_projects', 'Failed to fetch version data for %project (Fetch heads).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    return FALSE;
  }

  // Blacklist filters.
  $blacklisted_versions = variable_get('simplytest_projects_blacklisted_versions', array());
  foreach ($blacklisted_versions as $blacklisted) {
    foreach ($tags[1] as $key => $tag) {
      if (preg_match('!' . $blacklisted . '!', $tag)) {
        unset($tags[1][$key]);
      }
    }
    foreach ($heads[1] as $key => $head) {
      if (preg_match('!' . $blacklisted . '!', $head)) {
        unset($heads[1][$key]);
      }
    }
  }

  // Build the final versions array to save and return.
  $versions = array(
    'tags' => drupal_map_assoc($tags[1]),
    'heads' => drupal_map_assoc($heads[1]),
  );

  // Save the fresh data to database.
  $found = db_update('simplytest_projects')
    ->fields(array(
      'timestamp' => REQUEST_TIME,
      'versions' => serialize($versions),
    ))
    ->condition('shortname', $project)
    ->execute();

  watchdog('simplytest_projects', 'Fetched version data for %project.', array(
    '%project' => $project,
  ), WATCHDOG_NOTICE);

  return $versions;
}

/**
 * Fetches, saves and returns general project information.
 *
 * @param string $project
 *  The project's shortname to fetch information for.
 *
 * @return array
 *  An associative array containing:
 *   - title: Human readable project title
 *   - sandbox: Boolean whether it's a sandbox project.
 *   - type: What the projects type is.
 *   - creator: The projects creator.
 */
function simplytest_projects_fetch_project($project) {
  // To find out whether the project is a full one or not - we have to try.
  // Try as full project first.
  $result = drupal_http_request(SIMPLYTEST_PROJECTS_DRUPAL_ORG . 'project/' . $project);
  $sandbox = FALSE;
  if ($result->code != 200 && is_numeric($project)) {
    // Fallback to sandbox project
    $result = drupal_http_request(SIMPLYTEST_PROJECTS_DRUPAL_ORG . 'node/' . $project);
    $sandbox = TRUE;
  }
  if ($result->code != 200 || !isset($result->data)) {
    watchdog('simplytest_projects', 'Failed to fetch initial data for %project (Request).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    return FALSE;
  }

  // Try to match out the project title.
  preg_match_all('!<div class="block-inner">[^<]*<h2 class="">Maintainers for ([^<]*)</h2>!', $result->data, $title);
  if(!isset($title[1][0])) {
    watchdog('simplytest_projects', 'Failed to fetch initial data for %project (Fetch title).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    return FALSE;
  }
  $title = $title[1][0];

  // Try to match out the project type by term.
  preg_match_all('!<div id="node-\d*" class="node node-project-([^ ]*) clearfix">!', $result->data, $type);
  if(isset($type[1][0])) {
    $term = $type[1][0];
  }
  else {
    watchdog('simplytest_projects', 'Failed to fetch initial data for %project (Fetch type).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    $term = NULL;
  }

  // Try to match out the creator name.
  if ($sandbox) {
    preg_match_all('!Posted by <a href="/u/[^<]*" title="View user profile." data-uid="\d*" class="username">([^<]*)</a>!', $result->data, $creator);
    if(!isset($creator[1][0])) {
      watchdog('simplytest_projects', 'Failed to fetch initial data for %project (Fetch creator).', array(
        '%project' => $project,
      ), WATCHDOG_WARNING);
      return FALSE;
    }
    $creator = $creator[1][0];
  }
  else {
    // Creator is not relevant for full project webgit URLs.
    $creator = NULL;
  }

  // Find out the type.
  $type = simplytest_projects_get_project_type($term);
  if ($type === FALSE) {
    // Unknown type, error.
    watchdog('simplytest_projects', 'Failed to fetch initial data for %project (Determine type).', array(
      '%project' => $project,
    ), WATCHDOG_WARNING);
    return FALSE;
  }

  // Build an array of all the new project data.
  $data = array(
    'title' => $title,
    'shortname' => $project,
    'sandbox' => (int) $sandbox,
    'type' => $type,
    'creator' => $creator,
  );

  watchdog('simplytest_projects', 'Fetch initial data for %project.', array(
    '%project' => $project,
  ), WATCHDOG_NOTICE);

  // Now save the information about this project to database.
  db_insert('simplytest_projects')
    ->fields($data)
    ->execute();

  return $data;
}

/**
 * Inserts initial project data into database by a SimpleXML object.
 */
function simplytest_projects_xml_insert_project($xml) {
  // Try to figure out project type by term.
  if (!isset($xml->terms->term[0]->value)) {
    return FALSE;
  }
  $term = (string) $xml->terms->term[0]->value;
  $type = simplytest_projects_get_project_type($term);

  if ($type === FALSE) {
    // We don't import unsupported project types.
    return FALSE;
  }

  // Build an associative array of the projects data from the XML file.
  $data = array(
    'title' => (string) $xml->title,
    'shortname' => (string) $xml->short_name,
    // Sandbox project?
    'sandbox' => (int) (is_numeric((string) $xml->short_name) && substr($xml->link, 0, 26) === SIMPLYTEST_PROJECTS_DRUPAL_ORG . 'sandbox/'),
    // Get project type, as it is referenced as tag.
    'type' => $type,
    // Git creator name (for sandbox projects).
    'creator' => (string) substr(substr($xml->link, 26), 0, -(strlen($xml->short_name) + 1)),
  );

  // Save this project information into database.
  db_insert('simplytest_projects')
    ->fields($data)
    ->execute();
}

/**
 * Finds out the readable project type by term.
 *
 * @param string $term
 *  A drupal.org project term.
 *
 * @param string
 *  The corresponding project type.
 */
function simplytest_projects_get_project_type($term) {
  switch (strtolower(trim($term))) {
    case 'drupal core':
    case 'core':
      return SIMPLYTEST_PROJECTS_TYPE_CORE;

    case 'modules':
    case 'module':
      return SIMPLYTEST_PROJECTS_TYPE_MODULE;

    case 'themes':
    case 'theme':
      return SIMPLYTEST_PROJECTS_TYPE_THEME;

    case 'distributions':
    case 'distribution':
      return SIMPLYTEST_PROJECTS_TYPE_DISTRO;

    default:
      return FALSE;
  }
}

/**
 * Makes a HTTP HEAD request to an specific URL and return the status code.
 *
 * @param string $url
 *  The URL to send a request to.
 *
 * @return int
 *  The HTTP status code of the response.
 */
function simplytest_projects_get_http_status_code($url) {
  $response = simplytest_projects_get_headers($url);
  // Get the HTTP status code from the response headers.
  if (isset($response[0])) {
    $response_status = (int) substr($response[0], 9, 3);
  }
  else {
    $response_status = 0;
  }
  return $response_status;
}

/**
 * Wrapper function for the PHP get_headers().
 *
 * This function makes sure that correct stream defaults like user-agent
 * and http method set so the request wont be blocked by 404 forbidden
 * on servers requiring a User-Agent header to be set.
 *
 * @param string $url
 *  The URL to request the HTTP headers for.
 *
 * @return array
 *  An associative array of headers, keyed by HTTP header key.
 */
function simplytest_projects_get_headers($url) {
  stream_context_set_default(array(
    'http' => array(
      // Set HEAD request, instead of the default GET.
      'method' => 'HEAD',
      // Set a User-Agent header.
      'user_agent' => 'PHP',
    )
  ));
  return get_headers($url, TRUE);
}
